// Copyright 2018, Collabora, Ltd.
// SPDX-License-Identifier: BSL-1.0
// Author: Ryan A. Pavlik <ryan.pavlik@collabora.com>

use crate::{unbuffer::UnbufferConstantSize, Buffer};

/// Trait for computing the buffer size needed for types
/// that can be "buffered" (serialized to a byte buffer),
pub trait BufferSize {
    /// Indicates the number of bytes required in the buffer to store this.
    fn buffer_size(&self) -> usize;
}

impl<T: ConstantBufferSize> BufferSize for T {
    fn buffer_size(&self) -> usize {
        T::constant_buffer_size()
    }
}

pub trait WrappedConstantSize {
    type WrappedType: Buffer + UnbufferConstantSize + ConstantBufferSize;
    fn get(&self) -> Self::WrappedType;
    fn new(v: Self::WrappedType) -> Self;
}

impl<T: WrappedConstantSize> ConstantBufferSize for T {
    fn constant_buffer_size() -> usize {
        T::WrappedType::constant_buffer_size()
    }
}

/// Optional trait for things that always take the same amount of space in a buffer.
///
/// Implementing this trait gets you implementations of a bunch of buffer/unbuffer-related traits for free.
pub trait ConstantBufferSize {
    /// Get the amount of space needed in a buffer.
    fn constant_buffer_size() -> usize
    where
        Self: Sized,
    {
        std::mem::size_of::<Self>()
    }
}

/// Trait implemented by empty messages (no body)
/// so that they can easily get their trivial/null serialization support.
pub trait EmptyMessage: Default + std::fmt::Debug {}

impl<T: EmptyMessage> WrappedConstantSize for T {
    type WrappedType = ();
    fn get(&self) -> Self::WrappedType {}
    fn new(_v: Self::WrappedType) -> Self {
        Default::default()
    }
}
